[[section: โครงสร้างของโพรโตคอล TCP/IP]]

    โพรโตคอล TCP/IP มีการจ้ดการกลไกการทำงานเป็นชั้นหรือ Layer เรียงต่อกัน โดยในแต่ละเลเยอร์จะมีการทำงานเทียบได้กับ OSI Model มาตรฐาน 
    แต่บางเลเยอร์ของโพรโตคอล TCP/IP จะทำงานเทียบกับ OSI หลายเลเยอร์ปนกัน ซึ่งในแต่ละเลเยอร์ของโพรโตคอล TPC/IP จะประกอบด้วย
    [[ulist]]
    # Process Layer
    # Host-to-Host Layer
    # Internetwork Layer
    [[end]]
    โดยเมื่อเทียบกับมาตรฐาน ISO Model แล้วจะเป็นดังรูปด้านล่างซึ่งเราจะเห็นว่าบางกลไกของโพรโตคอล TCP/IP เทียบได้กับมาตรฐาน OSI Model สองชั้น 
    หรือบางกลไกก็จะทำงานคาบเกียวกันระหว่างชั้นของ OSI Model ตัวอย่างเช่น กลไกการทำงานของโพรโตคอล TCP/IP ในส่วน Network Interface Layer และ Physical Layer 2 ชั้นรวมกันเป็นต้น 
    ในแต่ละกลไกของโพรโตคอล TCP/IP จะมีโพรโตคอลอื่นๆในชุดของ TCP/IP ร่วมทำงานอยู่ด้วย ซึ่งจะกล่าวโดยละเอียดต่อไป

    [[subsection: Process layer]]
        จากรูป  แสดงลำดับชั้นการทำงานของโปรโตตอล TCP/IP เทียบกับมาตรฐาน OSI Model  นั้น 
        ในชั้นบนสุดเรียกว่า Process layer ทำงาน 2 หน้าที่เทียบได้กับ Application และ Presentation layer 
        ในชั้นนี้จะรองรับการทำงานของแอพพลิเคชันต่างๆที่ทำงานเป็นโปรเซส แต่อยู่ในเครื่องเซิร์ฟเวอร์ให้บริการและเครื่องที่ขอใช้บริการ หรือไคลเอนต์(client) 
        ซึ่งจะติดต่อกันผ่านโพรโตคอลเฉพาะแอพพลืเคชันอีกทีหนึ่ง ตัวอย่างเช่น เมื่อผู้ใช้งานอินเตอร์เน็ตต้องการโอนถ่ายไฟล์หรือ download ข้อมูลจากเครืองเซิร์ฟเวอร์ให้บริการ 
        โดยอาจะเรียกใช้โปรแกรม ftp client ทั่วไป เช่น โปรแกรม WS_ftp ติดต่อกับโปรเซส ftp ที่กำลังให้บริการอยู่ที่เครื่องเซิร์ฟเวอร์ จากนั้นตัวโปรเซส ftp 
        ก็จะเรียกใช้โพรโตคอล FTP(File Transfer Protocal) เพื่อทำการโอนถ่ายไฟล์นี้ หรือถ้าผู้ใช้ต้องการเรียกใช้งานคอมพิวเตอร์เครื่องที่อยู่ห่างไกลออกไปด้วยการใช้โปรแกรม Telnet เพื่อติดต่อกัน 
        หรือในกรณีที่มีการเรียกใช้โปรแกรม web browser เพื่อเรียกดูเว็บเพจในเว็บไซต์ ก็จะมีโปรเซส HTTP (HyperText Transfer Protocal) ทำงานอยู่และจะติดต่อกับผู้ใช้ผ่านโพรโตคอล HTTP เป็นต้น
        การทำงานของแอพพลิเคชันต่างๆจะอยู่ที่ Process layer นี้ และมีการติดต่อกันตามแต่ละโพรโตคอลเฉพาะแล้วแต่แอพพลีเคชันที่ใช้งาน จากการที่ Process layer 
        ของ TCP/IP รองรับให้โพรโตคอลอื่นที่ทำงานได้หลายโปรเซสและหลายโพรโตคอลได้พร้อมกันนั้น ทำให้ผู้ใช้สามารถเปิดโปรแกรมใช้งานได้หลายๆอย่างพร้อมกัน 
        เช่น เปิดโปรแกรม internet explorer เพื่อเรียกดูเว็บเพจ พร้อมกับใช้งานโปรแกรม outlook express เพื่อส่งอีเมลล์ไปพร้อมกันได้โดยไม่ต้องรอให้ทำงานอย่างหนึ่งอย่างใดเสร็จก่อน 
        หรือในปัจจุบันมีการพัฒนาโปรแกรม Web Browser ทำให้สามารถเรียกใช้งานโพรโตคอลอื่นๆ ได้มากขึ้น ทำให้เราสามารถใช้โปรแกรม web browser โอนถ่ายข้อมูลที่ใช้โพรโตคอล FTP ได้โดยไม่ต้องไปหาโปรแกรมอื่นมาใช้
        
        โพรโตคอลหลักๆที่ทำงานใน Process layer ซึ่งผู้ใช้มักจะคุ้นเคยกันดีได้แก่ FTP (File Transfer Protocol), Telnet, HTTP (HyperText Transfer Protocol) 
        และ SMTP (Simple mail Transfer protocol) นอกจากนี้ยังมีโพรโตคอลอื่นซึ่งทำงานโดยที่ผู้ใช้ไม่สามารถมองเห็นได้จากโปรแกรมหรือไม่ได้มีการใช้งานโดยตรง เช่น
        [[ulist]]
        # โพรโตคอล DNS (Domain Name System) ทำหน้าที่แปลงข้อมูลชื่อ domain name หรือชื่อเว็บไซต์ทั้งหลายให้เป็น ip address
        # โพรโตคอล SNMP (Simple Netwotk Management Protocol) ใช้ในการควบคุมและตรวจสอบอุปกรณ์ที่อยู่ในเครือข่าย
        # โพรโตคอล DHCP (Dynamic Host Configuration Protocol) ทำหน้าที่แจกจ่ายข้อมูลพารามิเตอร์ของเครือบ่ายให้กับเครื่องลูกข่ายที่เชื่อมต่ออยู่
        [[end]]

   
    [[subsection: Host-to-Host layer]]
        ผู้ที่ใช้งานอินเตอร์เน็ตเคยสงสัยหรือไม่ว่าเครื่องเซิ ร์ฟเวอร์ที่ให้บริการต่างๆ เช่น เว็บเซิร์ฟเวอร์นั้น เมื่อมีผู้เข้ามาเรียกใช้บริการพร้อมกันหลายคน 
        จะมีวิธีการส่งข้อมูลกลับไปยังต้นทางได้อย่างไรโดยไม่มีข้อผิดพลาด ซึ่งบางครั้งผู้ใช้รายหนึ่งอาจจะเปิดโปรแกรม web browser 
        ซ้อนกันเพื่ออ่านข้อมูลจากเว็บเพจอื่นพร้อมกันไปได้ ดังนั้นระบบจะทราบได้อย่างไรถึงการ
        
        การทำงานที่ชั้นของ Host-to-Host layer นี้จะมีบทบาทในการจัดการต่อจาก Process layer บางครั้งเรามักเรียกชั้น Host-to-Host layer 
        ว่าเป็น Transport layer ซึ่งไม่ใช่ชั้นของ Transport layer ในมาตรฐาน OSI Model การทำงานของ Host-to-Host layer นี้จะมีการสร้าง connection 
        หรือการเชื่อมต่อกันระหว่างแอพพลิเคชันกับ Host-to-Host layer โดยที่จุดเชื่อมกันเพื่อรับส่งข้อมูลนี้เรียกว่า port หรือ socket (คำว่า port ในที่นี้ไม่ได้หมายถึง port ในฮาร์ดแวร์) 
        และในแต่ละแอพพลิเคชันก็จะสร้างการเชื่อมต่อผ่าน port ได้พร้อมกันหลายแอพพลิเคชัน ซึ่งการใช้งาน port ของแต่ละแอพพลิเคชันที่อยู่ในชั้น Process layer จะแตกต่างกันตามหมายเลขที่กำหนดไว้ 
        และแต่ล่ะโพรโตคอลจะมีการใช้งาน port หมายเลขต่างๆ ตามรูป [[ref(Diagram1)]]

        [[image(Diagram1):network/Diagram1.jpeg|width=0.5|caption=ตัวอย่างพอร์ทที่ใช้ในแต่ละแอพพลิเคชัน]]

        เมื่อแอพพลิเคชันทำงานผ่านโพรโตคอลในชั้น Process layer จะมีการส่งผ่านข้อมูลไปยัง Host-to-Host layer ที่ชั้นนี้จะมีการเชื่อมต่อผ่าน port ที่กำหนด 
        ทำให้การรับส่งข้อมูลในแต่ละโพรโตคอลทำได้ถูกต้อง ถึงแม้ว่าในเครื่องเซิร์ฟเวอร์ที่ให้บริการจะมีการทำงานอยู่หลายโปรเซสที่แตกต่างกันก็ตาม 
        หรือมีผู้ใช้บริการเข้ามาใช้งานพร้อมกันจำนวนมากและหลายแอพพลิเคชันในเวลาเดียวกัน ในชั้น Host-to-Host หรือ Transport layer ของ TCP/IP นี้จะมีโพรโตคอลทำงานอยู่ 2 โพรโตคอลที่แตกต่างกัน 
        คือ โพรโตคอล TCP และโพรโตคอล UDP (User Datagram Protocol) ในการส่งผ่านข้อมูลลงไปที่ชั้นถัดๆไป เราจะเห็นว่าโพรโตคอล TCP และ UDP จะถูกผนึกเข้าไปในโพรโตคอล IP อีกทีหนึ่งและส่งต่อไปยังเครือข่ายอินเตอร์เน็ตต่อไป
        ตัวโพรโตคอล TCP และโพรโตคอล UDP จะมีแอพพลิเคชันเฉพาะเพื่อเรียกใช้งานแยกกันคือ แอพพลิเคชันที่ใช้โพรโตคอล FTP, Telnet, HTTP และ SMTP 
        จะมีการส่งผ่านข้อมูลโดยเรียกใช้โพรโตคอล TCP ส่วนแอพพลิเคชันที่ใช้โพรโตคอล SNMP และ DHCP จะส่งผ่านข้อมูลโดยเรียกใช้โพรโตคอล UDP และสำหรับโพรโตคอล DNS นั้น จะสามารถเรียกใช้ได้ทั้ง TCP และ UDP ดังภาพ [[ref(Diagram21)]]

        [[image(Diagram21):network/Diagram21.jpeg|width=0.5|caption=ภาพการใช้งานแอพพลิชัน กับโพรโตคอลที่ใช้งาน]]

    [[subsection: โพรโตคอล TCP]]
        โพรโตคอล TCP (Transmission Control Protocol) เป็นโพรโตคอลที่มีการรับส่งข้อมูลแบบ Stream oriented protocol หมายความว่า 
        การรับส่งข้อมูลจะไม่คำนึงถึงปริมาณข้อมูลที่จะส่งไป แต่จะแบ่งข้อมูลเป็นส่วนย่อยๆก่อน แล้วจึงจะส่งไปยังปลายทางอย่างต่อเนื่องเป็นลำดับข้อมูล ในกรณีที่ข้อมูลส่วนใดส่วนหนึ่งสูญหายไป 
        ก็จะส่งข้อมูลส่วนนั้นใหม่อีกครั้ง สำหรับปลายทางก็จะทำหน้าที่จัดเรียงส่วนของข้อมูล datagram ใหม่ให้ต่อเนื่องและประกอบกับเป็นข้อมูลทั้งหมดได้ ซึ่งจะแยกข้อมูลที่ไม่ถูกต้องออก 
        ดังนั้นแอพพลิเคชันหรือโปรเชสใดที่อาศัยการส่งผ่านข้อมูลด้วยโพรโตคอล TCP จะต้องใช้หน่วยความจำและขนาดช่องสัญญาณ (bandwidth) มากกว่า UDP
        
        การติดต่อระหว่างกันจะต้องเป็นแบบ Connection-oriented คือต้องมีการสร้างการติดต่อกันเป็น session ทั้ง 2 ด้านเสียก่อน แล้วจึงจะรับส่งข้อมูลไปได้พร้อมกัน(Full Duplex) 
        เหมือนกับการใช้โทรศัพท์ติดต่อกัน เมื่อผู้ติดต่อต้นทางเรียกให้ฝ่ายตรงข้ามรับสายแล้ว จึงเริ่มสนทนา เช่น พูดคำว่า "สวัสดี" หรือ "ฮัลโหล" กันก่อนเพื่อให้แน่ใจว่าฝ่ายตรงข้ามพร้อมที่จะติดต่อด้วย 
        จากนั้นจึงเริ่มติดต่อกัน และเมื่อต้องการเลิกติดต่อกันก็จะมีการพูดคำว่า "สวัสดี" ให้ฝ่ายตรงข้ามทราบว่าจะเลิกการติดต่อและวางสายไป ซึ่งในระหว่างการติดต่อกันนั้น แม้ว่าฝ่ายใดฝ่ายหนึ่งหรือทั้งสองจะเงียบไป 
        คือไม่พูดอะไรเป็นเวลานานๆ แต่การเชื่อมโยงระหว่างทั้งสองด้านยังคงมีอยู่ไม่ขาดจนกว่าจะมีฝ่ายใดฝ่ายหนึ่งวางสาย เช่นเดียวกับการติดต่อกันด้วยกลไกลโพรโตคอล TCP 
        เมื่อแอพพลิเคชันต้องการส่งผ่านข้อมูลจะใช้โพรโตคอลที่เหมาะสมในชั้น Process layer ติดต่อไปและมีการสร้างช่องส่งข้อมูลผ่าน port ที่กำหนดเพื่อส่งผ่านข้อมูลไปยังโพรโตคอล TCP
        ในระหว่างการรับส่งข้อมูลนี้ โพรโตคอล TCP จะเพิ่มขบวนการสอบทานข้อมูลเพื่อให้ข้มูลมีความถูกต้องไม่ผิดพลาดไปจากเดิม โดยการส่งสัญญาณสอบทานข้อมูล (acknowledgerment) 
        และส่งข้อมูลให้ใหม่อีกครั้ง ถ้าปลายทางไม่ได้รับหรือเกิดความผิดพลาดขึ้น ความน่าเชื่อถือของการส่งผ่านข้อมูลโดยโพรโตคอล TCP จะมีมากกว่า แต่ตั้งอาศัยทรัพยากรของระบบเช่นกัน
        % [[image(TCPIP):network/TcpIp.png|width=0.5|caption=ภาพการประเฟรมของโพรโตคอล TCP/IP]]

    [[subsection: โพรโตคอล UDP]]
    ใน Host-to-Host layer นอกจากจะมีโพรโตคอล TCP ทำงานแล้ว ยังมีโพรโตคอล UDP (User Datagram Protocol) ที่มีคุณสมบัติแตกต่างกันอยู่ด้วย 
    ในการรับส่งข้อมูลผ่านโพรโตคอล UDP จะเป็นแบบที่ทั้งสองด้านไม่จำเป็นต้องอาศัยการสร้างช่องทางเชื่อมต่อกัน (connectionless) 
    ระหว่างเครื่องเซิร์ฟเวอร์ให้บริการกับเครื่องที่ขอใช้บริการ โดยไม่ต้องแจ้งให้ฝ่ายรับข้อมูลเตรียมข้อมูลเหมือนโพรโตคอล TCP และไม่มีการตรวจสอบความถูกต้องของข้อมูลนั้นๆด้วย 
    เนื่องจากโพรโตคอล UDP ไม่มีสัญญาณสอบทานข้อมูล (acknowledgement) ในการส่งข้อมูลแต่ล่ะครั้งและไม่มีการส่งข้อมูลใหม่อีกในกรณีที่เกิดความผิดพลาดของการส่งข้อมูล 
    เมื่อเป็นเช่นนี้แอพพลิเคชันหรือโปรเซสใดที่ต้องอาศัยโพรโตคอล UDP ในการส่งผ่านข้อมูลก็อาจจะต้องสร้างขบวนการตรวจสอบข้อมูลขึ้นมาเอง
    
    ตามรูป [[ref(Diagram21)]] จะเห็นว่าโพรโตคอลชั้นบนขึ้นไป ที่ใช้การส่งผ่านข้อมูลโดยโพรโตคอล UDP เช่น โพรโตคอล SNMP 
    (ใช้ควบคุมและจัดการอุปกรณ์ในเครือข่าย) หรือโพรโตคอล DHCP (ใช้ส่งข้อมูลพารามิเตอร์ของเครือข่ายให้กับเครือข่ายให้กับเครื่องลูกข่ายได้ใช้งาน) 
    การส่งข้อมูลเหล่านั้นไม่ต้องรับทราบหรือตรวจสอบว่าข้อมูลไปถึงปลายทางหรือไม่ แต่กลไกการตรวจสอบข้อมูลที่มีการรับส่งจะไปทำในขั้นตอนของโพรโตคอลชั้นที่สูงแทน
    ตัวอย่างขั้นตอนกลไกการทำงานโดยใช้โพรโตคอล UDP มีดังนี้
    [[ulist]]
    # ในชั้นของ Process layer เมื่อโปรแกรมควบคุมอุปกรณ์เครือข่ายเช่น โปรแกรม Network Management ต้องการส่งข้อมูลไปยังอุปกรณ์ที่ต้องการ แอพพลิเคชันนั้นจะติดต่อผ่านโพรโตคอล SNMP ในชั้น Process layer
    # โพรโตคอล SNMP จะติดต่อกับโพรโตคอล UDP ในชั้นถัดไป เพื่อขอติดต่อผ่าน port ที่กำหนด
    # โปรโคคอล SNMP เตรียมข้อมูลที่จะส่ง รวมทั้งที่อยู่ปลายทาง
    # โพรโตคอล SNMP ส่งผ่านข้อมูลให้โพรโตคอล UDP ที่อยู่ในชั้น Host-to-Host layer
    # โพรโตคอล UDP ทำหน้าที่ผนึกข้อมูลหรือ datagram นั้นไปกับโพรโตคอล IP ในชั้นถัดลงไป เพื่อส่งข้อมูลออกจากเครื่อง
    [[end]]

    ซึ่งจะเห็นว่ามีกลไกที่ต่างจากการส่งข้อมูลด้วยโพรโตคอล TCP ซึ่งจะต้องมีการติดต่อกันก่อน และทั้งสองฝ่ายรับทราบการรับส่งข้อมูลของช่องการส่งข้อมูลนั้น

    [[subsection: Internetwork layer]]
        ในระดับล่างต่อมาในชั้น Internetwork layer มีหน้าที่ส่งผ่านข้อมูลในระหว่างเครือข่าย 
        โดยมีโพรโตคอลที่ทำงานเป็นกลไกสำคัญในการส่งผ่านข้อมูลไปยังเครือข่ายใดๆ บนอินเตอร์เน็ต 
        คือ โพรโตคอล IP (Internet Protocol) นอกจากนี้ในชั้น Internetwork layer 
        ยังมีโพรโตคอลทำงานอยู่ด้วยอีก 2 ชนิดคือ โพรโตคอล Internet Control Message Protocol (ICMP) 
        และโพรโตคอล Address Resolution Protocol (ARP)
        
        [[subsubsection: โพรโตคอล IP]]
            โพรโตคอล IP ทำหน้าที่ให้บริการส่งผ่านข้อมูลที่มาจาก Host-to-Host layer เพื่อส่งข้ามไปยังเครือข่ายใดๆ 
            ได้อย่างถูกต้อง แม้ว่าจะมีเครือข่ายเชื่อมต่อกันอยู่ในอินเตอร์เน็ตเป็นล้านเครือข่ายก็ตาม เนื่องจากโพรโตคอล IP 
            มีข้อมูลตำแหน่ง IP ปลายทางที่จะส่งข้อมูลไปให้ โดยทำงานร่วมกับอุปกรณ์ Router 
            เพื่อส่งข้อมูลข้ามเครือข่ายออออกไปได้ ตัวโพรโตคอล IP จะทำงานแบบ packet switching 
            คือมีการส่งข้อมูลผ่านสวิทซ์(switch)ไปยังปลายทาง โดยข้อมูลจะเดินทางไปยังเครือข่ายต่างๆผ่านสวิทซ์นี้ไปเรื่อยๆจนกว่าจะถึงปลายทาง 
            ตัววงจรผ่านหรือ switch นี้อาจจะเป็น Gateway หรือ Router ในระบบเครือข่ายก็ได้ ซึ่งในข้อมูลของโพรโตคอล IP จะมีข้อมูลของหมายเลข IP 
            ปลายทางที่จะส่งข้อมูลไปและเมื่อถึงเครือข่ายปลายทางแล้ว จะมีกลไกแปลงหมายเลข IP ให้เป็นหมายเลขฮาร์ดแวร์ประจำเครื่องที่ถูกต้องอีกทีหนึ่งด้วยโพรโตคอล ARP 
            ตามรูป [[ref(Diagram2)]] จะแสดงการติดต่อกันระหว่างโพรโตคอลในชั้นของ Host-to-Host layer และ Internetwork layer
        
        [[subsubsection: โพรโตคอล ICMP]]
        หน้าที่หลักของโพรโตคอล ICMP (Internet Control Message Protocol) คือ การแจ้งหรือแสดงข้อความจากระบบ 
        เพื่อบอกให้ผู้ใช้ทราบว่าเกิดอะไรขึ้นในการส่งผ่านข้อมูลนั้น ซึ่งปัญหาส่วนมากที่พบคือส่งออกไปไม่ได้ หรือปลายทางรับข้อมูลไม่ได้ เป็นต้น 
        นอกจากนี้โพรโตคอล ICMP ยังถูกเรียกใช้งานได้จากเครื่องเซิร์ฟเวอร์และ Router อีกด้วย เพื่อแลกเปลี่ยนข้อมูลที่ใช้ควบคุม ส่วนรูปแบบการทำงานของโพรโตคอล ICMP 
        นั้นจะทำงานควบคู่กับโปรโคคอล IP ในระดับเดียวกัน และข้อความต่างๆที่แจ้งให้ทราบจะถูกผนึกอยู่ภายในข้อมูล IP (IP datagram)อีกทีหนึ่ง
        [[image(Diagram2):network/Diagram2.jpeg|width=0.5|caption=ภาพแสดงการติดต่อกันระหว่างโพรโตคอลในชั้นของ Host-to-Host layer และ Internetwork layer ]]

        [[subsubsection: โพรโตคอล ARP]]
            โพรโตคอล ARP (Address Resolution Protocol) ถูกเรียกใช้งานโดยโพรโตคอล IP เพื่อช่วยแปลงหมายเลข IP 
            ไปเป็นหมายเลขฮาร์ดแวร์ปลายทาง ตัวอย่างเช่น เว็บเซิร์ฟเวอร์เครื่องหนึ่งเชื่อมต่ออยู่ในเครือข่ายอินเตอร์เน็ต 
            และในการเชื่อมต่อนี้ต้องอาศัย Network Interface Card (NIC) หรือ LAN Card ติดตั้งอยู่ ที่ Lan card นี้เองจะมีหมายเลขเฉพาะประจำฮาร์ดแวร์ที่ไม่ซ้ำใคร 
            เพื่อใช้ในการอ้างอิงการส่งข้อมูลในเครือข่าย แต่เมื่อมาใช้ในโพรโตคอล TCP/IP ก็จะต้องมีการกำหนดหมายเลข ip address ประจำตัวเพื่อใช้อ้างอิงกัน 
            และโพรโตคอล ARP จะทำหน้าที่แปลงค่าหมายเลข IP ให้เป็นหมายเลขฮาร์ดแวร์จริงให้ในระดับการทำงานที่ Internet layer นี้ซึ่งกลไกการแปลงเรียกว่า Address resolution

    [[subsection:  Network Interface layer]]
        เนื่องจากในด้านกายภาพของเครือข่ายนั้น มีหลายวิธีการและหลายรูปแบบในการเชื่อมต่อระบบเครือข่าย แต่อย่างไรก็ตามในเครือข่ายอินเตอร์เน็ตนี้ 
        ข้อมูลหรือ IP Datagram จะถูกถ่ายทอดและส่งผ่านไปยังปลายทางโดยไม่คำนึงถึงรูปแบบการเชื่อมต่อทางกายภาพ 
        ไม่ว่าจะเป็นการใช้เครือข่ายใยแก้วนำแสงหรือเครือข่ายสาย Unshielded Twist pair (UTP) เชื่อมต่อเป็นแบบเครือข่าย Ethernet 
        ธรรมดาหรือเครือข่าย Token Ring, ATM, ISDN ฯลฯ ก็ตาม
        
        การทำงานระดับล่างสุดต่อจาก Internetwork layer จะเป็นการแปลงข้อมูล IP datagram ให้อยู๋ในรูปที่เหมาะสม และแปลงสัญญาณไฟฟ้าส่งไปยังเครือข่ายต่อไป 
        ซึ่งในชั้น Network Interface Layer นี้เทียบกับมาตรฐาน OSI Model แล้วจะเป็นการรวมเลเยอร์ 2 เลเยอร์เข้าด้วยกันคือ 
        Datalink layer และ Physical layer กล่าวโดยสรุปคือ การทำงานตามโครงสร้างของโพรโตคอล TCP/IP จะมีลักษณะดังรูป [[ref(Diagram3)]]
        [[image(Diagram3):network/Diagram3.jpeg|width=0.5|caption=โครงสร้างโพรโตคอล TCP/IP ]]

        [[subsubsection: การทำงานของ TCP/IP]]
        กล่าวสรุปคือ โปรโตคอล TCP/IP ทำงานโดยแบ่งชั้นเทียบกับ OSI Model ได้ กลไกในการทำงานของโปรโตคอล TCP/IP มี 4 ชั้น ซึ่งในชั้นแรก คือ Process layer 
        ทำหน้าที่ติดต่อกับแอพพลิเคชันและโปรโตคอลที่แอพพลีเคชันนั้นๆใช้งาน และส่งต่อมาให้ชั้น Host-to-Host layer เพื่อติดต่อกันระหว่างเครื่องเซิร์ฟเวอร์ให้บริการกับเครื่องผู้ขอใช้บริการ 
        ในชั้นนี้จะมีการสร้าง session หรือการเชื่อมต่อระหว่างระบบขั้นตามแต่ละโปรโตคอลที่ต้องการ ต่อมาเป็นการผนึกข้อมูลไปเป็น IP datagram ที่ชั้น Internetwork layer โดยอาศัยโปรโตคอล IP 
        เพื่อให้สามารถติดต่อส่งข้อมูลข้ามเครือข่ายไปยังเครือข่ายและเครื่องที่ถูกต้องได้ และสุดท้ายการส่งข้อมูลออกสู่โลกภายนอกต้องอาศัยกลไกในชั้น Network Interface Layer โดยอาศัยโปรโตคอล IP 
        เพื่อให้สามารถติดต่อส่งข้อมูลออกสู่โลกภายนอกต้องอาศัยกลไกในชั้น Network Interface layer เพื่อแปลงข้อมูลใหม่ เพิ่มข้อมูลที่จำเป็นในการอ้างอิงตำแหน่งและแปลงข้อมูลเป็นสัญญาณไฟฟ้าส่งออกไปยังเครือข่าย 
        และอาจจะออกไปยัง Gateway หรือ Router เพื่อข้ามเครือข่ายออกไปยังเส้นทางที่กำหนดไว้ในอินเตอร์เน็ตต่อไป

[[section: Python]] 
    เป็นภาษาสคริปท์ที่มีรูปแบบภาษาที่เข้าใจง่าย มีไลบารี่ที่อำนวยความสะดวกครบครัน และสามารถหาเอกสารอ้างอิงได้ง่ายเพราะเป็นภาษาโปรแกรมที่ได้รับความนิยม

[[section: pyFirmata]]
    เป็น Libery สำหรับภาษา Python ใช้สำหรับติดต่อกับบอร์ดตระกูล Arduino 

[[section: Java ]]
    ภาษา Java เป็นภาษาสำหรับเขียนโปรแกรมที่สนับสนุนการเขียนโปรแกรมเชิงวัตถุ (Object-Oriented Programming)
    โปรแกรมที่เขียนขึ้นถูกสร้างภายในคลาส ดังนั้นคลาสคือที่เก็บเมทอด (Method) หรือพฤติกรรม (Behavior) ซึ่งมีสถานะ (State) 
    และรูปพรรณ (Identity) ประจำพฤติกรรม (Behavior)

[[section: Android SDK]]
    ย่อมาจาก Android Software Development Kit พัฒนาและแจกจายฟรีไม่มีค่าใช้จ่ายโดย Google 
    สำหรับเป็นเครื่องมือสำหรับพัฒนาแอพพลิเคชันบน Android ผู้พัฒนาสามารถพัฒนาแอพพลิเคชันได้อย่างรวดเร็วและมี Emulator 
    สำหรับจำลองอุปกรณ์ Android บนเครื่องคอมพิวเตอร์ที่ใช้พัฒนาได้อีกด้วย

[[section: MJPEG ]]
    คือการบีบอัดไฟล์วิดีโอรูปแบบหนึ่งซึ่งประกอบจากการแสดงภาพแบบ JPEG ต่อกันทีละเฟรมจนเกิดเป็นภาพเคลื่อนไหว
    การบีบอัดรูปแบบ MJPEG นิยมใช้ในการจับภาพเคลื่อนไหวในกล้องวงจรปิด IP Camera เพราะใช้การประมวลจาก CPU น้อย
    เนื่องจากไม่จำเป็นต้องบีบอัข้อมูล ทำให้ลดการใช้งานของ CPU

[[section: LinkIt Smart 7688 Duo (Linux Embedded)]]

    Linux Embedded คืออุปกรณ์สมองกลฝังตัวมีระบบปฏิบัติ Linux เป็นซอฟแวร์ในการจัดการทรัพยากร 
    โดยที่ LinkIt Smart 7688 Duo เป็นบอร์ด Embedded ระบบปฏิบัติการ Linux OpenWrt  
    เหมาะสำหรับอุปกรณ์ที่เน้นการเชื่อมต่อเครือข่ายคอมพิวเตอร์ หรือประยุกต์ใช้งานกับระบบที่เชื่อมต่อกับเครือข่ายทั้งมีสายและไร้สาย 
    ผลิตโดยความร่วมมือของ MediaTek และ SeeedStudio ใช้ชิพ MT7688 ของ MediaTek 
    สถาปัตยกรรม MIPS ความเร็ว 580 MHz มีหน่วยความจำ DDR2 ขนาด 128MB 
    มี Flash Memory ขนาด 32 MB พร้อม Wi-Fiมาตรฐาน 802.11bgn พร้อมขาสัญญาณต่างๆ 
    ให้ใช้งาน ได้แก่ GPIO I2C SPI UART PWM Ethernet USB Host และ Micro SD Card Slot
    จากภาพ [[ref(7688-duo_spec)]], แสดงรายละเอียดของบอร์ด LinkIt Smart 7688 Duo.

    [[image(7688-duo_spec):7688Linkit/7688duoallspec.jpg|width=0.5|caption=LinkIt Smart 7688 Duo]]

[[section: Wi-Fi  ( Wireless-Fidelity)  ]]
    เป็นเทคโนโลยีเครือข่ายไร้สาย  ภายใต้เทคโนโลยีการสื่อสาร มาตรฐาน IEEE  802.11  โดยเป็นมาตรฐานที่ถูกอนุมัติให้ 
    ใช้จาก IEEE (The Institute of Electrical and Electronics Engineers) 
    เพื่อให้อุปกรณ์คอมพิวเตอร์สามารถสื่อสารกันได้บนมาตรฐานการทำงานแบบเดียวกัน  สำหรับเทคโนโลยีเครือข่ายไร้สายนี้จะใช้คลื่นความถี่ RF 
    และคลื่นความถี่อินฟาเรตในการรับส่งข้อมูลคลื่นความถี่วิทยุของเครือข่ายไร้สายจึงสามารถทะลุทะลวงกำแพง
    หรือสิ่งกีดขวางได้ทำให้การใช้งานบนเครือข่ายไร้สายมีความคล่องตัวและสะดวกสบายมากขึ้น 
    โดยสามารถเชื่อมต่อเข้าสู่เครือข่ายได้ทุกที่ที่มีคลื่นสัญญาณ ข้อมูลจะถูกรับส่งผ่านคลื่นวิทยุความถี่ 2.4 GHz 
    ด้วยความเร็ว  11 Mbps  ระยะห่างประมาณ  300 ฟุต นำมาใช้ในการรับส่งข้อมูลระหว่างตัวรถและชุดบังคับ
 
[[section: HTTP Live Streaming]]
    การสตรีมมิ่งวิดีโอ คือการแสดงผลภาพเคลื่อนไหวจากกล้องหรือไฟล์ไปยังลูกข่าย(Client) 
    โดยที่ผู้ชมจะได้รับการแสดงผลแบบ Real timne ซึ่งการสตรีมมิ่งผ่าน HTTP
    ถือว่าเป็นอีกหนึ่งช่องทางที่ได้รับความนิยม เนื่องจากความสะดวกในการพัฒนาและมีอุปกรณ์รองรับได้เป็นจำนวนมาก

[[section: Servo Motor]]
    คือ Motor ที่สามารถสั่งงานให้หมุนไปยังตำแหน่งองศาที่ต้องการถูกต้อง 
    โดยใช้การควบคุมแบบป้อนกลับ(Feedback Control)  Feedback Control 
    คือ ระบบควบคุมที่มีการวัดค่าเอาต์พุตของระบบนำมาเปรียบเทียบกับค่าอินพุตเพื่อควบคุมและปรับแต่งให้ค่าเอาต์พุตของระบบให้มีค่าเท่ากับ 
    หรือใกล้เคียงกับค่าอินพุต Servo motor มีสายเชื่อมต่อเพื่อจ่ายไฟฟ้า และควบคุม 
    จะประกอบด้วยสายไฟ 3 เส้น คือ ไฟเลี้ยง (4.8-6V) กราวด์ และสายส่งสัญญาณพัลซ์ควบคุม (3-5V) 
    หลักการทำงานของ RC Servo Motor เมื่อจ่ายสัญญาณพัลซ์เข้ามายัง RC Servo Motor 
    ส่วนวงจรควบคุม (Electronic Control System) ภายใน Servo 
    จะทำการอ่านและประมวลผลค่าความกว้างของสัญญาณพัลซ์ PWM (Pulse Width Modulation) 
    ที่ส่งเข้ามาเพื่อแปลค่าเป็นตำแหน่งองศาที่ต้องการให้ Motor 
    หมุนเคลื่อนที่ไปยังตำแหน่งนั้น แล้วส่งคำสั่งไปทำการควบคุมให้ Motor 
    หมุนไปยังตำแหน่งที่ต้องการ โดยมี Position Sensor เป็นตัวเซ็นเซอร์คอยวัดค่ามุมที่ Motor กำลังหมุน 
    เป็น Feedback กลับมาให้วงจรควบคุมเปรียบเทียบกับค่าอินพุตเพื่อควบคุมให้ได้ตำแหน่งที่ต้องการอย่างถูกต้องแม่นยำ
    ยกตัวอย่างเช่นหากกำหนดความกว้างของสัญญาณพัลซ์ไว้ที่ 1 ms ตัว Servo Motor จะหมุนไปทางด้ายซ้ายจนสุด 
    ในทางกลับกันหากกำหนดความกว้างของสัญญาณพัลซ์ไว้ที่ 2 ms 
    ตัว Servo Motor จะหมุนไปยังตำแหน่งขวาสุด แต่หากกำหนดความกว้างของสัญญาณพัลซ์ไว้ที่ 
    1.5 ms ตัว Servo Motor ก็จะหมุนมาอยู่ที่ตำแหน่งตรงกลางพอดี 
    ดังนั้นสามารถกำหนดองศาการหมุนของ Servo Motor ได้โดยการเทียบค่า 
    เช่น Servo Motor สามารถหมุนได้ 180 องศา 
    โดยที่ 0 องศาใช้ความกว้างพัลซ์เท่ากับ 1000 us ที่ 180 องศาความกว้างพัลซ์เท่ากับ 2000 us 
    เพราะฉะนั้นค่าที่เปลี่ยนไป 1 องศาจะใช้ความกว้างพัลซ์ต่างกัน (2000-1000)/180 เท่ากับ 5.55 us 
    จากการหาค่าความกว้างพัลซ์ที่มุม 1 องศาข้างต้น หากต้องกำหนดให้ RC Servo Motor 
    หมุนไปที่มุม 45 องศาจะหาค่าพัลซ์ที่ต้องการได้จาก 5.55 x 45 เท่ากับ 249.75 us 
    แต่ที่มุม 0 องศาเราเริ่มที่ความกว้างพัลซ์ 1ms หรือ 1000 us เพราะฉะนั้นความกว้างพัลซ์ที่ใช้กำหนดให้ RC Servo Motor 
    หมุนไปที่ 45 องศา คือ 1000 + 249.75 เท่ากับประมาณ 1250 us

    [[image(servo):motor/servor03.jpg|width=0.5|caption=Servo Motor]]